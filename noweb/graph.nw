\documentclass{article}

\usepackage{noweb}

\begin{document}

\section{Graph Library}

All data on the system will be storage in a graph structure. So that,
first we must provide a graph library. Althought most languages offer
libraries for dealing with edges and nodes, we have developed our own
class since we must, on each node, preserve the order of its
childs. Most libraries do not consider this necessity.

On the top of the [[graph.py]] file we import the Python module
\verb|copy|. This module provide facilities to create duplicated
objects an not just references.

<<graph.py>>=
from copy import *

<<class node>>
<<class edge>>
<<class graph>>

@

The class \verb|Node| store the information of nodes. Each node has an
field named \verb|label|. Actually, each deduction system will need
the store much more information on each node. Thanks to the Python
flexibility, fields can be store into objects even if the class of
that object do not declare it.

<<class node>>=
class Node:
    def __init__(self, label):
	self.graph = None
	self.label = label

    def __str__(self):
	return self.label

@

The methods \verb|add_childs| and \verb|add_child| were used to wrap
the methods \verb|add_node| and \verb|add_edge| from the \verb|Graph|
class. Unfortunately, Python does not allow polymorphism of methods so
we were not able to write just one method to deal with list of nodes
and node.

<<class node>>=
    def add_child(self, node, edge):
        self.graph.add_node(node)
        self.graph.add_edge(self, node, edge)

    def add_childs(self, nodes, edge):
        for n in nodes:
            self.add_child(n, edge)

@

To retrieve the list of childs or the list of out edges from a node we
also implemented to more methods on the class \verb|Node|. Note that
the method \verb|get_out_edges| is flexible enough to retrieve just
the childs or edges that return true when the function received as
parameter were applied to it.

<<class node>>=
    def get_out_edges(self, func=None):
        edges = self.graph.out_edges(self)
        if f_filter:
            edges = filter(func, edges)
        if edges:
            return edges
	else:
	    return []

    def get_childs(self, f):
        edges = self.get_out_edges(func==f)
        if edges:
            return [x[0] for x in edges]
        else:
            return []

@

Testando.

<<class edge>>=
class Edge:
    def __init__(self):
        self.graph = g
        
@

Testando.

<<class graph>>=
class Graph:
    def __init__(self):
        self.name = 'ass'

@

Teste.


\end{document}
